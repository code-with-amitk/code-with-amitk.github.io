<!DOCTYPE html>
<html>
    <head>
        <title>Rust</title>
        <link rel="stylesheet" href="/css/styles.css"/>
        <link rel="stylesheet" href="/css/prism.css">
        <!-- Add any necessary CSS and JavaScript files -->
    </head>
    <body>
        <nav class="navbar">
            <ul>
            <li><a href="#">Home</a></li>
            <li><a href="#">Our team</a></li>
            <li><a href="#">Projects</a></li>
            <li><a href="#">Contact</a></li>
            <li>
                <form>
                    <input type="search" name="q" placeholder="Search site" />
                    <input type="submit" value="Go!" />
                </form>
            </li>
            </ul>
        </nav>

        <aside class="sidebar">    <!--See .sidebar in styles.css-->
            <a href="#why">Why Rust Over C++</a>
            <ul>
                <li><a href="#ownership">Ownership</a></li>
                <li><a href="#borrowing">Safe Borrowing</a></li>
            </ul>
            <a href="install.html">Install Rust</a>
            <a href="Functions.html">Functions(Closure)</a>
        </aside>

        <article style="margin-left:200px;">
            <h3 id="why">Why Rust Over C++</h3>
            <h4 id="ownership">Ownership <font color="red">(avoid crash in Rust)</font></h4>
            <dd>
                Variable or data can have single owner at a time. When a value is assigned to a variable, that variable becomes 
                the owner of the value. When the owner goes out of scope, Rust automatically deallocates the memory used by the value.<br>
                Ownership rules are checked at compile time.<br>
                Ownership applies to memory allocated on heap(dynamically),
                 Eg: String(), vector ie those are moved. For variable allocated on Stack (Eg: int, float) variable is copied.
            </dd>
            <dd>
                In Rust, raw pointers (*const T and *mut T) don't embody ownership semantics directly.
                However, smart pointers like Box<T>, Rc<T>, and Arc<T> do.<br>
                - Box<T>: It represents ownership of a heap-allocated value.<br>
                - Rc<T>: It provides reference counting and allows multiple ownership.<br>
                - Arc<T>: It's like Rc<T>, but with atomic reference counting, suitable for concurrent access.
            </dd>
            <table>
                <tr>
                    <td>C++ (Crash in C++)</td>
                    <td>Rust (No null pointer Exception(Crash) in Rust)</td>
                </tr>
                <tr>
                    <td>    <!--C++-->
                        <pre><code class="language-css">
int main() {
    std::string* s = new std::string("hello");

    // s1 now points to the same memory as s
    std::string* s1 = s;

    // Deallocate memory through s
    delete s; 

    // CRASH
    // Accessing memory through s1 leads to undefined behavior
    std::cout << *s1; 

    return 0;
} // Memory pointed to by s1 was 
// deallocated by delete, but s1 still holds the address
                        </code></pre> 
                    </td>
                    <td>
                        <pre><code class="language-css">
fn main() {
    // Box owns the heap-allocated String
    let s = Box::new(String::from("hello")); 

    // Ownership transferred to s1
    let s1 = s; 

    // This line would cause a compilation error in Rust
    // Error: value borrowed here after move
    // The ownership of the String was moved to s1, 
    //so s is no longer valid to use
    // println!("{}", s);

    // The String is still valid through s1
    println!("{}", s1);
} // Box goes out of scope, 
// and the String is deallocated automatically
                            
                        </code></pre>
                    </td>
                </tr>
            </table>

            <h4 id="borrowing">Safe Borrowing = Reference (&var)</h4>
            <dl>Borrowing means passing the reference of a variable.</dl>

            <dl id="danglingreferences"><strong>1. Dangling References (Allowed in C++, but not in Rust).
                <font color="red">Avoids Crash in Rust</font>
            </strong></dl>
            <dd>
                <u>Dangling pointer?</u> Pointer points to memory, memory is freed and pointer is used.<br>
                <u>Dangling reference?</u> Similar to Dangling pointer, when reference to a value is used, 
                value is freed and reference is used after that.
            </dd>
            <table>
                <tr>
                    <th></th>
                    <th>C++</th>
                    <th>Rust</th>
                </tr>
                <tr>
                    <td>Dangling References</td>
                    <td>
                        Dangling References Allowed in C++
                        <pre><code class="language-css">
//Function returning reference
int& fun() {
    int b = 10;
    return b;
}

int main() {
    //a is reference variable pointing to b,
    which does not exist    
    int &a = fun();
    cout &lt;&lt; a;            
}
# g++ test.cpp   //No compile error
# ./a.out
    Segmentation Fault
                    </code></pre>
                    </td>
                    <td>
                        Dangling References Not Allowed in Rust
                        <pre><code class="language-css">
fn fun() -> &i32 {
    let b = 10;
    &b     //Reference returned
}
fn main() {
    let a = fun();
}
$ cargo build
| fn fun() -> &i32
|             ^ expected named lifetime parameter
                    </code></pre></td>
                </tr>
            </table>

            <br>
            <dl><strong>2. Mutable References</strong></dl>
            <table>
                <tr>
                    <th></th>
                    <th>C++</th>
                    <th>Rust</th>
                </tr>
                <tr>
                    <td>Mutable?</td>
                    <td>
                        References are mutable by Default in C++
                        <pre><code class="language-css">
// Passed value by reference
// Changed inside fun
void test (int& a) {
    a = 20;
}
int main()
{
    int a = 10;
    test(a);
    cout &lt;&lt; a;
}
                    </code></pre>
                    </td>
                    <td>
                        References are IMMUTABLE by Default in Rust
                        <table>
                            <tr>
                                <td>
                                    References are IMMUTABLE by default
                                    <pre><code class="language-css">
fn fun(a: &i32) {
    *a = 20;
}
fn main() {
    let a = 10;
    fun(&a);
    println!("{}",a);
}
$ cargo build
Error
cannot mutate immutable variable `a`
                                    </code></pre>
                                </td>
                                <td>
                                    References are made MUTABLE explicitly
                                    <pre><code class="language-css">
// Passed mutable reference
fn fun(a: &mut i32) {
    *a = 20;
}
fn main() {
    // variable made mutable
    let mut a = 10;

    // passed mutable ref
    fun(&mut a);
    println!("{}",a);
}                                        
                                    </code></pre>
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr>


                </tr>
            </table>

        </article>
        <script src="/scripts/prism.js"></script>
    </body>
</html>

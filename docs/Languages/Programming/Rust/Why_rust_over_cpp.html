<!DOCTYPE html>
<html>
    <head>
        <title>Rust</title>
        <link rel="stylesheet" href="/css/styles.css"/>
        <link rel="stylesheet" href="/css/prism.css">
        <!-- Add any necessary CSS and JavaScript files -->
    </head>
    <body>
        <nav class="navbar">
            <ul>
            <li><a href="#">Home</a></li>
            <li><a href="#">Our team</a></li>
            <li><a href="#">Projects</a></li>
            <li><a href="#">Contact</a></li>
            <li>
                <form>
                    <input type="search" name="q" placeholder="Search site" />
                    <input type="submit" value="Go!" />
                </form>
            </li>
            </ul>
        </nav>

        <aside class="sidebar">    <!--See .sidebar in styles.css-->
            <a href="">Rust No Crash</a>
            <ul>
                <li><a href="#ownership">1. Ownership</a></li>
                <li><a href="#borrowing">2. Borrowing</a></li>
                <li><a href="#mma">3. No Manual Memory management</a></li>
            </ul>
            <a href="">Faster wrt C++</a>
            <ul>
                <li><a href="#aco">4. Aggressive Complier Optimizations</a></li>
            </ul>
        </aside>

        <article style="margin-left:200px;">
            <dl>
                <a><b>No Crash in Rust due to:</b></a>
                <ul>
                    <li><a href="#ownership">1. Ownership</a></li>
                    <li><a href="#borrowing">2. Borrowing</a></li>
                    <li><a href="#mma">3. No Manual Memory management</a></li>
                </ul>
                <a><b>Faster wrt C++:</b></a>
                <ul>
                    <li><a href="#aco">4. Aggressive Complier Optimizations</a></li>
                </ul>
            </dl>

            <h2 id="why">Rust Over C++</h2>
            <table>
                <tr>
                    <th></th>
                    <th>C++</th>
                    <th>Rust</th>
                </tr>
                <tr>
                    <td>
                        <a href="#ownership">Ownership</a>
                    </td>
                    <td>No concept of ownership</td>
                    <td>Yes</td>
                </tr>
                <tr>
                    <td>
                        <a href="#borrowing">Reference(or Borrowing)</a>
                    </td>
                    <td>Unsafe (Lead to crashes)</td>
                    <td>Safe (No crash)</td>
                </tr>
            </table>


            <h3 id="ownership">1. Ownership <font color="red">(avoid crash in Rust)</font></h3>
            <dt><b>Ownership?</b><br>
                - Variable or data can have single owner at a time. When a value is assigned to a variable, that variable becomes 
                the owner of the value. When the owner goes out of scope, Rust automatically deallocates the memory used by the value.<br>
                - Ownership rules are checked at compile time. Ownership applies to memory allocated on heap(dynamically),
                 Eg: String(), vector ie those are moved. For variable allocated on Stack (Eg: int, float) variable is copied.
            </dt>
            <br>
            <dd>
                In Rust, raw pointers (*const T and *mut T) don't embody ownership semantics directly.
                However, smart pointers like Box<T>, Rc<T>, and Arc<T> do.<br>
                - Box<T>: It represents ownership of a heap-allocated value.<br>
                - Rc<T>: It provides reference counting and allows multiple ownership.<br>
                - Arc<T>: It's like Rc<T>, but with atomic reference counting, suitable for concurrent access.
            </dd>
            <table>
                <tr>
                    <td>C++ <font color="red">(Crash in C++)</font></td>
                    <td>Rust (No null pointer Exception(Crash) in Rust)</td>
                </tr>
                <tr>
                    <td>    <!--C++-->
                        <pre><code class="language-css">
int main() {
    std::string* s = new std::string("hello");

    // s1 now points to the same memory as s
    std::string* s1 = s;

    // Deallocate memory through s
    delete s; 

    // CRASH
    // Accessing memory through s1 leads to undefined behavior
    std::cout << *s1; 

    return 0;
} // Memory pointed to by s1 was 
// deallocated by delete, but s1 still holds the address
                        </code></pre> 
                    </td>
                    <td>
                        <pre><code class="language-css">
fn main() {
    // Box owns the heap-allocated String
    let s = Box::new(String::from("hello")); 

    // Ownership transferred to s1
    let s1 = s; 

    // This line would cause a compilation error in Rust
    // Error: value borrowed here after move
    // The ownership of the String was moved to s1, 
    //so s is no longer valid to use
    // println!("{}", s);

    // The String is still valid through s1
    println!("{}", s1);
} // Box goes out of scope, 
// and the String is deallocated automatically
                            
                        </code></pre>
                    </td>
                </tr>
            </table>

            <h3 id="borrowing">2. Borrowing = Reference (&var)</h3>
            <dt><b>Borrowing?</b> <br>
                - Borrowing means passing the reference of a variable.<br>
                - Borrowing in Rust is Safer wrt C++, which avoids <font color="red">Crashes/Dangling References</font>.
            </dt>

            <h4 id="danglingreferences">2.1 Dangling References (Allowed in C++, but not in Rust)
            </h4>

            <dt>
                <strong>Dangling pointer?</strong> Pointer points to memory, memory is freed and pointer is used.<br>
                <strong>Dangling reference?</strong> Similar to Dangling pointer, when reference to a value is used, 
                value is freed and reference is used after that.
            </dt>
            <br>
            <table>
                <tr>
                    <th></th>
                    <th>C++ <font color="red">(Crash in C++)</font></th>
                    <th>Rust</th>
                </tr>
                <tr>
                    <td>Dangling References</td>
                    <td>
                        Dangling References Allowed in C++
                        <pre><code class="language-css">
//Function returning reference
int& fun() {
    int b = 10;
    return b;
}

int main() {
    //a is reference variable pointing to b,
    which does not exist    
    int &a = fun();
    cout &lt;&lt; a;            
}
# g++ test.cpp   //No compile error
# ./a.out
    Segmentation Fault
                    </code></pre>
                    </td>
                    <td>
                        Dangling References Not Allowed in Rust
                        <pre><code class="language-css">
fn fun() -> &i32 {
    let b = 10;
    &b     //Reference returned
}
fn main() {
    let a = fun();
}
$ cargo build
| fn fun() -> &i32
|             ^ expected named lifetime parameter
                    </code></pre></td>
                </tr>
            </table>

            <br>
            <h4>2.2 Mutable References</h4>
            <dt>
                - References are mutable by Default in C++ <font color="red">(This can cause issues)</font><br>
                - (By default)References are IMMUTABLE in Rust, we need to make them mutable explicitly.
            </dt>
            <table>
                <tr>
                    <th></th>
                    <th>C++</th>
                    <th>Rust</th>
                </tr>
                <tr>
                    <td>Mutable?</td>
                    <td>
                        References are mutable by Default in C++
                        <pre><code class="language-css">
// Passed value by reference
// Changed inside fun
void test (int& a) {
    a = 20;
}
int main()
{
    int a = 10;
    test(a);
    cout &lt;&lt; a;
}
                    </code></pre>
                    </td>
                    <td>
                        References are IMMUTABLE by Default in Rust
                        <table>
                            <tr>
                                <td>
                                    References are IMMUTABLE by default
                                    <pre><code class="language-css">
fn fun(a: &i32) {
    *a = 20;
}
fn main() {
    let a = 10;
    fun(&a);
    println!("{}",a);
}
$ cargo build
Error
cannot mutate immutable variable `a`
                                    </code></pre>
                                </td>
                                <td>
                                    References are made MUTABLE explicitly
                                    <pre><code class="language-css">
// Passed mutable reference
fn fun(a: &mut i32) {
    *a = 20;
}
fn main() {
    // variable made mutable
    let mut a = 10;

    // passed mutable ref
    fun(&mut a);
    println!("{}",a);
}                                        
                                    </code></pre>
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>

            <br>
            <dl><strong>2.2.1 Borrow Transfers the ownership</strong></dl>
            <table>
                <td>
                    <b><font color="red">Crash in C++:</font> If vector<int*> in place of vector<int></b>
                    <pre><code class="language-css">
int main()
{
    vector<int> v = { 1,2,3 };
    int* a = &v[0];
    v.push_back(4);
    *a = 10;
}
                    </code></pre>
                </td>
                <td>
                    <b><font color="green">Rust(No Crash)</font> Cannot Change Borrowed value</b>
                    <pre><code class="language-css">
fn main() {
    let mut v = vec![1,2,3];
    let mut a = &mut v[0];
    v.push(4);
    println!("{}", a);
}
$ cargo run
error[E0499]: cannot borrow `v` as mutable more than once at a time
 --> src/main.rs:4:5
                    </code></pre>
                    - The code might look like should work.<br>
                    - Adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space.<br>
                    - if there isn’t enough room to put all the elements next to each other where the vector currently is. 
                    In that case, the reference to the first element would be pointing to deallocated memory.<br>
                    - The borrowing rules prevent programs from ending up in that situation.                    
                </td>
            </table>

            <br>
            <dl><strong>2.2.2 Two Mutable references not allowed in same scope</strong></dl>
            <table>
                <td>
                    <b><font color="red">C++ Crash</font></b>
                    <pre><code class="language-css">
int main()
{
    char* s1 = new char[1];
    char* s2 = s1;
    *s1 = 'a';
    delete s1;
    cout << "val=" << (*s2);
}
$ g++ test.cpp
Crash or Undefined behaviour
                    </code></pre>
                </td>
                <td>
                    <font color="blue"><b>Rust(No Crash, But compiletime error)</b></font><br>
                    Why not allowed in Rust?<br>
                    This can be a race condition, where if both mutable references change the data, there is no mechanism 
                synchronize access to the data
                    <pre><code class="language-css">
fn main() {
    let mut s = String::from("hello");
    let r1 = &mut s;
    let r2 = &mut s;
    println!("{}, {}", r1, r2);
}
$ cargo build
error[E0499]: cannot borrow `s` as mutable more than once at a time
                                    </code></pre>
                </td>
            </table>

            <h3 id="mma">3. No Manual Memory management <font color="red">(avoid crash in Rust)</font></h3>
            <dt>
                - Rust does not provide `new, delete` operators as in C++ for dynamically allocate memory.<br>
                - Rust's ownership and borrowing rules ensure memory safety without the need for manual memory management. 
            </dt>
            <table>
                <td>
                    C++
                    <pre><code class="language-css">
int* ptr = new int[10]; // Allocates memory of 10 integer
delete ptr; // Deallocates the memory pointed to by ptr
                    </code></pre>
                </td>
                <td>
                    Rust.
                    <pre><code class="language-css">
let mut arr: Vec<i32> = Vec::with_capacity(10);     //malloc
let arr: Vec<i32> = vec![0; 10];                    //malloc + memset
                    </code></pre>
                </td>
            </table>

            <h3 id="aco">4. Aggressive Compiler Optimization <font color="green">(make Rust fast)</font></h3>
            <h4>1. Inlining</h4>
            <dt>
                - Rust's Compiler(LLVM) optimizes code more aggressivly wrt C++ compiler
                & this is because of ownership rules, LLVM can make assumptions.<br>
                - LLVM is more aggressive about inlining functions, especially for small functions. 
                Inlining avoids function call overhead and makes it fast.
            </dt>

        </article>
        <script src="/scripts/prism.js"></script>
    </body>
</html>

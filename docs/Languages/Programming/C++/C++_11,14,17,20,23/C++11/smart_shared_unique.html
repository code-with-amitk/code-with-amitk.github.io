<!DOCTYPE html>
<html>
<head>
    <title>Pointers</title>
    <link rel="stylesheet" href="/css/styles.css"/>
    <link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
    <nav class="navbar">    <!--See .navbar in styles.css-->
        <ul>
          <li><a href="#">Home</a></li>
          <li><a href="#">Our team</a></li>
          <li><a href="#">Projects</a></li>
          <li><a href="#">Contact</a></li>
          <li>
            <form>
                <input type="search" name="q" placeholder="Search site" />
                <input type="submit" value="Go!" />
            </form>
           </li>
        </ul>
    </nav>

    <aside class="sidebar">    <!--See .sidebar in styles.css-->
        <a href="#pointers">Pointers</a>
        <dl>
            <li>
                <a href="#raw">Raw</a>
                <a href="#smart">Smart</a>
                <dl>
                    <li>
                        <a href="#unique">Unique</a>
                        <a href="#shared">Shared</a>
                        <dl>
                            <li>
                                <a href="#internal">Internal Implementation</a>
                            </li>
                        </dl>
                    </li>
                </dl>
            </li>
        </dl>
    </aside>

    <article style="margin-left:200px;">
        <h2 id="pointers">Pointers</h2>

        <h3 id="raw">Raw Pointers</strong></h3>
        <pre><code>
            // As defined in C
            int *p = new int();         //p is raw pointer.
        </code></pre>

        <h3 id="smart">Smart pointers</h3>
        <dl>
            Automatically deletes the allocated memory when goes out of scope.<br>
            <b>How?</b> Allocate memory in ctr, Delete memory in dtr. Bcoz Destructors are automatically executed when Object goes out of scope.<br>
            <b>Why?</b> Programmer may allocate memory using new() & later might forget to use delete().
        </dl>
        <pre><code class="language-css">
template <class T>		
class A{                    //This class is Smart pointer
    T *a;         //int *a;
public:
    A(T *r):a(r){ cout << "Allocated\n"; }              //A(int *r):a(r)
    ~A(){
        delete a;
        cout << "Freed\n";
    }
    T &operator *(){        //int &operator *()    //& returns a only, does not create new copy
        return *a;
    }
};

int main(){
    //Automatic template type deduction => Provided in C++17
    A <int> obj(new int());	//obj is my pointer now. I can carry all pointer operations
    *obj = 10;
    cout<<*obj<<"\n";

    A <float> obj1(new float());
}

# g++ smart_pointers
Allocated
10
Allocated 

Freed
Freed
        </code></pre>

        <h4>Unique vs Smart pointer</h4>
        <table>
            <tr>
                <th></th>
                <th>Unique</th>
                <th>Shared</th>
            </tr>
            <tr>
                <td>What</td>
                <td>Only 1 Owner of memory, ie only 1 pointer to an object</td>
                <td>Multiple owners of a resource</td>
            </tr>
            <tr>
                <td>Copy Constructible</td>
                <td>No, any attempt to make a copy of a unique_ptr will cause a compile-time error. copy ctr, assignment operator are deleted</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Move Constructible</td>
                <td>Yes,can be moved using the new move semantics</td>
                <td>Yes</td>
            </tr>
        </table>
        <h4 id="unique">1. Unique pointer (type of smart pointer)</h4>
        <table>
            <tr>
                <td>
                    <pre><code class="language-css">
int main(){
    unique_ptr&lt;int> p(new int(5));          //Unique Pointer for int
    cout &lt;&lt; *p;                               //5

    //error: use of deleted function. copy of UP is not allowed
    //unique_ptr&lt;int> p1 = p;
    
    //Moving ownership
    unique_ptr&lt;int> p2 = std::move(p);      
    cout &lt;&lt; *p2;                              //5
    //cout &lt;&lt; *p;                             //Segmentation Fault
    p2.reset();
/*
make_unique<T>()
    - Avoid use of new operator
    - Provides exception safety, as new and delete internally handled by compiler. 
    - Memory is allocated to 0.
*/
    unique_ptr&lt;int> p1 = make_unique<int>();  //Create UP using make_unique()
    cout&lt;&lt;*p1 &lt;&lt; endl;               //0
        
//////UP for char array////////
    std::unique_ptr&lt;PWSTR[]>    m_pwstrPath;    //PWSTR: pointer to wide str

    //Allocate char array of 260 chars and Initialize to ()
    m_pwstrPath = (PWSTR*) new TCHAR[260]();    
}
                    </code></pre>
                </td>
                <td>
                    <b>Copy Constructible(No):</b> There can be only one unique_ptr to any resource,<br>
                    any attempt to make a copy of a unique_ptr will cause a compile-time error.
                    <pre><code class="language-css">
unique_ptr&lt;T> ptr(new T);       // Okay
unique_ptr&lt;T> cptr = ptr;       // Error: Can't copy unique_ptr
                    </code></pre>

                    <b>Move Constructible(Yes)</b>
                    <pre><code class="language-css">
unique_ptr<T> ptr(new T);             // Okay
unique_ptr&lt;T> cptr = std::move(ptr);  // Okay, resource now stored in cptr
                    </code></pre>
                </td>
            </tr>
        </table>

        <h4 id="shared">2. Shared pointer (type of smart pointer)</h4>
        <table>
            <tr>
                <td>
                    <pre><code class="language-css">
int main(){
    //Allocated int, made shared_ptr point to it
    shared_ptr &lt;int> ptr (new int(5));
    //ptr,ptr1 now points to same memory
    shared_ptr &lt;int> ptr1 = ptr;

    cout &lt;&lt; *ptr;     //Ouput:5
    cout &lt;&lt; *ptr1;    //Output:5

    ptr.reset();        //Deleting ptr
    cout &lt;&lt; *ptr1;  //5 But ptr1 still points to memory

    ptr1.reset();            //Deleting ptr1
    //cout &lt;&lt; *ptr;    //Segmentation Fault
}
                    </code></pre>
                </td>
                <td>
                    <b>Copy Constructible(Yes):</b> Multiple pointers can point to same resource<br>
                    Owner count is maintained using reference counting<br>
                    When none is referencing the memory, it's deleted automatically.
                    <pre><code class="language-css">
shared_ptr &lt;int> p   =   int* p   //We can think like this

shared_ptr &lt;T> ptr(new T);       // Okay
shared_ptr &lt;T> cptr = ptr;       // Okay.  Are Copy Constructible
                    </code></pre>
                    <br>

                    <b>Copy Initialization(No):</b> When we initialise with =, we invoke copy-initialisation<br>
                    Why CI not allowed? Because shared_ptr constructor is explicit and a <br>
                    explicit construtor is not copy-assignable
<pre><code class="language-css">
int main() {
    int* b = new int;

    //Copy Initialization. conversion from 'int*' 
    // to non-scalar type 'std::shared_ptr' requested
    shared_ptr &lt;int> a = b;     
    ..
    // second ptr holding b... fails concept of shared_ptr
    shared_ptr &lt;int> a1 = b;   
}
                </code></pre>
                </td>
            </tr>
        </table>

        <h5 id="internal">How shared_ptr is implemented internally?</h5>
        <dl>
            shared_ptr maintains 2 things.<br>
            Creation of shared_ptr: reference_count=1<br>
            On every new shared_ptr creation: reference_count++<br>
            Deletion/Reset: reference_count--
        </dl>
        <pre><code>
int reference_count;
T* data;                  //and a pointer to the object being shared

template &lt;typename T>
class shared_ptr {
    struct ControlBlock {   //stores a pointer to the object being shared (T* ptr_) and a reference count (int ref_count_).
        T* ptr_;
        int ref_count_;
    };    
    ControlBlock* data_;
public:
    shared_ptr(T* ptr) {
        data_ = new ControlBlock;
        data_->ptr_ = ptr;
        data_->ref_count_ = 1;
    }
    
    shared_ptr(const shared_ptr& other) {
        data_ = other.data_;
        data_->ref_count_++;
    }
    
    ~shared_ptr() {
        if (--data_->ref_count_ == 0) {
            delete data_->ptr_;
            delete data_;
        }
    }    
};
        </code></pre>

    </article>

    <script src="/scripts/prism.js"></script>
</body>
</html>

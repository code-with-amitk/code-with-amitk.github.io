<!DOCTYPE html>
<html>
<head>
    <title>Class Templates</title>
    <link rel="stylesheet" href="/css/styles.css"/>
    <link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
    <nav class="navbar">    <!--See .navbar in styles.css-->
        <ul>
          <li><a href="/">Home</a></li>
          <li><a href="#">Our team</a></li>
          <li><a href="#">Projects</a></li>
          <li><a href="/contact.html">Contact</a></li>
          <li>
            <form>
                <input type="search" name="q" placeholder="Search site" />
                <input type="submit" value="Go!" />
            </form>
           </li>
        </ul>
    </nav>

    <aside class="sidebar">    <!--See .sidebar in styles.css-->
        <a href="#classtemplates">Class Template</a>
        <ul>
            <li>
                <a href="#internal">How Internally works?</a> 
            </li>
        </ul>
        <a href="#0template">0 templated argument</a>
    </aside>

    <article style="margin-left:200px;">
        <h2 id="classtemplates">Class Templates</h2>
        <dl>
            Generic class which having(Generic member variables, Generic member functions)
        </dl>
        <pre><code class="language-css">
template &lt;class T>            //OR &lt;typename T>
class A {
    //Generic Member variables
    A a, b;
public:
    A (T x, T y) : a(x), b(y) {}
    A add ();
};

//Template statement need to be written again when template class function is defined outside template class
//
template &lt;class T>
T A &lt;T>::add(){
    return a+b;
}

int main() {
    //Compiler cannot deduce template parameter type(s) for class template. 
    //We need to tell compiler the data types we would be using
    A &lt;int> obj(5,6);
    cout &lt;&lt; obj.add();          //11

    A &lt;float> obj1(5.6,6.7);
    cout &lt;&lt; obj1.add();

    //If arguments are of other type and template-type of other type. Compiler will ignore Argument type
    A &lt;int> obj2(5.6,6.7);           //C
    cout &lt;&lt; obj2.add();
}
        </code></pre>

        <h3 id="internal">How Internally works?</h3>
        <dl>
            On compile time, compiler creates seperate class for different parameter types.
        </dl>
        <pre><code class="language-css">
/*
Test &lt;int>::Test()     //class-1
Test &lt;double>::Test()  //class-2
*/
template &lt;class T>
class Test
{
    T val;
public:
    static int count;
    Test()  {   count++;   }
};

//Only 1 copy of static variable is kept per class
template &lt;class T>
int Test &lt;T>::count = 0;

int main() {
    Test &lt;int> a;
    Test &lt;int> b;
    Test &lt;double> c;
    cout &lt;&lt; Test &lt;int>::count;       //2
    cout &lt;&lt; Test &lt;double>::count;      //1
    return 0;
}
        </code></pre>

        <h2 id="0template">0 templated argument</h2>
        <pre><code class="language-css">
//0 templated arguments
template &lt; int n >
struct st {
    static const int val = 2 * st<n-1>::val;
};

//0 templated arguments
template &lt;>
struct st &lt; 0 > {
    static const int val = 1 ;
};

int main() {
    cout &lt;&lt; s&lt;10>::val;                //Output=1024
    return 0;
}
        </code></pre>
    </article>

    <script src="/scripts/prism.js"></script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <title>Exception Handling</title>
    <link rel="stylesheet" href="/css/styles.css"/>
    <link rel="stylesheet" href="/css/prism.css"/>
</head>
<body>
    <nav class="navbar">    <!--See .navbar in styles.css-->
        <ul>
          <li><a href="/">Home</a></li>
          <li><a href="#">Our team</a></li>
          <li><a href="#">Projects</a></li>
          <li><a href="/contact.html">Contact</a></li>
          <li>
            <form>
                <input type="search" name="q" placeholder="Search site" />
                <input type="submit" value="Go!" />
            </form>
           </li>
        </ul>
    </nav>

    <aside class="sidebar">    <!--See .sidebar in styles.css-->
        <a href="#what">What is Exception</a>
        <a href="#ttc">try, throw, catch</a>
        <a href="#ex">Examples</a>
        <ul>
            <li><a href="#divide">Divide by 0</a></li>
            <li><a href="#numeric_limits">numeric_limits</a></li>
            <li><a href="#constructor">Exception in constructor</a></li>
        </ul>
        <a href="#class">Exception class</a>
        <ul>
            <li><a href="#empty">Empty Exception class</a></li>
            <li><a href="#whatmethod">Exception class having what() method</a></li>
            <li><a href="#null">NULLException class</a></li>
        </ul>
    </aside>

    <article style="margin-left:200px;">
    <h2 id="what">What is Exception</h2>
    <dl>
        Exception is the problem state into which program enters that's not normal. 
        Now exception floats into callstack until handler is found for it.<br>
        if Handler is found (ie appropriate catch then ok) else <b>std::terminate</b> is invoked and the program exits.<br>
        <u>Examples of exception:</u><br>
        - Divide by Zero.<br>
        - Accessing out of bound array index. //Segmentation Fault and abort.<br>
        But we can place the same code inside try, catch and do something so that program does no coredumps.
    </dl>

    <h2 id="ttc">try, throw, catch</h2>
    <dl>
        In case of problem instead of simply dying(std::terminate, coredump), transfer control from one part of a program to another. This is build on 3 keywords:<br>
        1. try block: This need to be protected<br>
        2. throw keyword: Instead of dying, throw exception that should be handled in some other part of code<br>
        3. catch: This catches the thrown exception. This is piece of code that executes on thrown Exception.
    </dl>
    <h2 id="ex">Examples</h2>
    <h3 id="divide">Divide by 0</h3>
    <pre><code class="language-css">
int main() {
    int a = 0;
    try {                             //Protected Code
        if (a == 0)
            throw runtime_error("Divide by 0");
        int b = 1/a;
    }
    catch (runtime_error& e) {
        cout &lt;&lt; "runtime error:" &lt;&lt; e.what();
    } catch (...) {
        cout &lt;&lt; "Exception";
    }
}
    </code></pre>
    <h3 id="numeric_limits">numeric_limits</h3>
        <pre><code class="language-css">
void MyFunc(int c) {
    if (c > numeric_limits&lt;char>::max()) {
        throw invalid_argument("MyFunc argument too large.");
    }
}

int main() {
    try {
        MyFunc(256); //cause an exception to throw
    }
    catch (invalid_argument& e) {
        cerr &lt;&lt; e.what();
        return -1;
    }
    return 0;
}
        </code></pre>

        <h3 id="constructor">Exception in Constructor</h3>
        <pre><code class="language-css">
class base {
    char* ptr;
public:
base() {
    ptr = nullptr;
    ptr = new char[10];
    if (ptr == nullptr) 
        throw std::bad_alloc();        //Exception thrown from constructor
}
~base(){
    std::cout &lt;&lt; "base dtr\n";
}
};
int main() {
    try {
        base b;
    }
    catch (std::bad_alloc& b) {
        std::cout &lt;&lt; "Bad alloc" &lt;&lt; b.what();
    }
    catch(...){
        std::cout &lt;&lt; "Exception happened";
    }    
}
        </code></pre>

        <h2 id="class">Exception class</h2>
        <dl>
        Exception class is used to create our own exception types.
        </dl>
        <dl>
        <b>Why own exception types are needed?</b><br>
        1. We want to display custom message to user at time of exception.<br>
        2. Perform some logging on Log server. Block security sensitive information from being dumped. An exception might contain sensitive information, we donot want to show this to user.
        </dl>

        <h3 id="empty">Empty Exception class</h3>
        <dl>
            a. In try block we throw OBJECT of class type<br>
            b. catch, catches the object and displays it
        </dl>
        <pre><code class="language-css">
class demo {};
int main() {
    try {
        throw demo();                   //a
    }
    catch (demo d) {                  //b
        cout &lt;&lt; "Caught exception of demo class \n";
    }
}
        </code></pre>
        <h3 id="whatmethod">Exception class having what() method</h3>
        <pre><code class="language-css">
class BadLength {
    int a;
public:
    BadLength(int x):a(x){}
    int what(){
        return a;
    }
};
int main() {
    int len;
    cin >> len;
    try {
        if (len &lt; 5)
            throw BadLength(len);             //1. Call constructor of class
        else
            cout &lt;&lt; "Len is Fine";
    } catch (BadLength b) {
        cout &lt;&lt; "Too Short:" &lt;&lt; b.what();
    }
}
        </code></pre>
        <h3 id="null">NULLException class</h3>
        <dl>
            1. Create a class called NULLException. This class will: Log message to Log server, print custom information with Exception message<br>
            2. Throw the custom class.<br>
            3. Catch the custom class.
        </dl>
        <pre><code class="language-css">
////////////Example//////////////////
class NULLException { ... }
main ()
    try {
        throw NULLException;
    } catch (NULLException obj) {
        cout &lt;&lt; obj.what ();
    } catch (...) {               //This will not be executed
    }

/////////////////Code////////////////
class base {
protected:
    char* m_msg = nullptr;
private:
    void copyMsg (const char *test) {       //Deep copy
        char *customMessage = "Amit ";                      //Added Custom Message
        if ( test != nullptr ) {
            delete [] m_msg;
            m_msg = nullptr;
        }
        size_t size = strlen (test);
        m_msg = new char [size+6];
        memset (m_msg, '\0', size);

        memcpy (m_msg, customMessage, 5);
        memcpy ((char*)m_msg+5, test, size);                      //3
    }

public:
    base (const char* m) : m_msg(nullptr) { //Default ctr doing deep copy
        copyMsg (m);
        cout &lt;&lt; "Logged message on Log server\n";
    }
    base (const exception& obj) {         //copy ctr doing deep copy
        copyMsg (obj.what());
    }
    base& operator = (const base& obj) {    //Assigment operator deep copy
    if (this != &obj)
        copyMsg(obj.what());
    }
    virtual ~base() {                     //Destructor
    if ( nullptr != m_msg) {
        delete [] m_msg;
        m_msg = nullptr;
    }
    }
    virtual const char* what() const {
    return m_msg;
    }
};

class NULLException : public base {
public:
    explicit NULLException (const char *msg) : base (msg) {}
};

int main() {
    try {
    char *ptr = nullptr;

    if (ptr == nullptr)
        throw NULLException ("NULL Exception");

    } catch (const NULLException &obj ) {
    printf ("%s\n",__FILE__);                       //2
    cout &lt; obj.what();                     //3
    } catch (...) {
    cout &lt;&lt; "Catch ellipse block";                  //Will not executed
    }
}
/*Output
Logged message on Log server                  //1
filename.cpp                                  //2 
Amit Null Exception                           //3
        </code></pre>
    </article>

    <script src="/scripts/prism.js"></script>
</body>
</html>

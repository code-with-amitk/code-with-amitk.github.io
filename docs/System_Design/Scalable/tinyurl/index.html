<!DOCTYPE html>
<html>
  <head>
    <title>Tiny URL</title>
    <link rel="stylesheet" href="/css/styles.css"/>
    <link rel="stylesheet" href="/css/prism.css"/>
  </head>

<body>
  <nav class="navbar">    <!--See .navbar in styles.css-->
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="#">Our team</a></li>
      <li><a href="#">Projects</a></li>
      <li><a href="/contact.html">Contact</a></li>
      <li>
        <form id="searchForm">
            <input type="search" id="searchInput" name="q" placeholder="Search site" />
            <input type="submit" value="Go!" />
        </form>
        </li>
    </ul>
  </nav>

  <aside class="sidebar">
    <a href="#what">What</a>
    <a href="#req">Requirements</a>
    <a href="#boe">BOE</a>
    <a href="#systemapis">System APIs</a>
    <a href="#partioning">Databases</a>
    <ul>
      <li><a href="#sqltables">SQL Tables</a></li>
      <li><a href="#partitioning">DB Scaling & Paritioning</a></li>
    </ul>
    <a href="#hld">HLD</a>
    <ul>
      <li><a href="#authenticate">Authenticate to RESTful APIs</a></li>
      <li><a href="#reachmicroservice">Reach Microservice from public network</a>
      <li><a href="#bhld">Basic Design</a></li>
      <li><a href="#problems">Problems in Basic Design</a></li>
    </ul>
  </aside>

  <main>
    <article style="margin-left:200px;">
        <h3 id="what">What is Tiny URL</h3>
        <dd>
          This service will provide shortened aliases redirecting to long URLs. Users are redirected to longURL as they hit short URL.<br>
          Short links save a lot of space when displayed, printed, messaged, or tweeted. Additionally, users are less likely to mistype shorter URLs.
        </dd>
        <dl>
          This would be Read-Heavy, Read:Write=100:1
        </dl>

        <h3 id="req">1. Requirements</h3>
        <h4>Functional</h4>
        <dd>CRUD(Create=POST, Read=GET, Update=PUT, Delete=DELETE)</dd>
        <dl id="req1"> 1. (Create=POST) Create shorturl from long url</dl>
        <dl id="req2"> 2. (Read=GET) Read Big URL From tinyurl</dl>
        <dl id="req3"> 3. (Update) When bigurl is updated, old tinyurl should be updated</dl>
        <dl id="req4"> 4. (Delete) Delete existing tinyurl</dl>

        <h4>Non Functional</h4>
        <dd>
          S<sup>3</sup>:(Scalable,Secure,SOA), L<sup>3</sup>:(Latency, Load, Logging), 
          A<sup>3</sup>:(Accurate, Available, Authenticated), C<sup>2</sup>:(Cache),
          R<sup>2</sup>:(Reliable, Redundant) F<sup>2</sup>:(fast, Fault Tolerant)
        </dd>
        <dl id="nonfuncreq1">1. Scalable.
          if user creates, 100k urls at same time, system should not delay</dl>
        <dl id="nonfuncreq2">2. Reliable: Everytime user hits shorturl, it should provide same bigurl</dl>
        <dl id="nonfuncreq3">3. Available: On high load, system should be available. (CRUD=READ)</dl>

        <h3 id="boe">2. BOE</h3>
        <dl><strong>QPS Estimates:</strong>
          //Ask Interviewer. Incoming requests/sec
        </dl>
        <p>
          - 25000/86400 req/sec.  1 request/4 seconds<br>
          - 25000 requests/day<br>
          - 25000 x 30 = 750,000 requests/month<br>
          - 750,000 x 12 x 5 = 450 Million requests/5years
        </p>

        <dl><strong>Storage Estimates:</strong></dl>
        <p>
          Shortened URL: 6 bytes
          Long URL: 250 bytes
          Storage for 5 years: 260 x 450M = 117 GB
        </p>

        <dl><strong>Bandwidth Estimates:</strong></dl>
        <p>
            - 1 request/4 seconds<br>
            - 1 GET request = 2KB<br>
          
            > Incoming bytes = 1 x 2k = 2000Bytes/5 sec<br>
            > Outgoing bytes = same
        </p>
        
        <h3 id="systemapis">3. System APIs</h3>
        <dl><strong><a href="#req1">1. (Create=POST) Create shorturl from long url</a></strong></dl>
        <pre><code class="language-css">
POST /api/v1/api_name(get_short_url) HTTP/1.1    //Check other fields in HTTP POST
request parameter: {longUrl: longURLString}
        </code></pre>

        <dl><strong><a href="#req2">2. (Read=GET) Read Big URL From tinyurl</a></strong></dl>
        <pre><code class="language-css">
GET /api/v1/api_name(get_long_url) HTTP/1.1    //Check other fields in HTTP POST
request parameter: {shortUrl: shortURLString}
        </code></pre>

        <h3 id="database">4. Databases</h3>

        <h3 id="hld">5. High Level Design</h3>
        <h4><a href="#req1">Req1. (Create=POST) Create shorturl from long url </a></h4>
        <h5>1 user, 1 server</h5>
        
        <pre><code class="language-css">
          client                             Server
          ---------POST api/v1/longurl--------->
                                             longurl => |Hash_Fun| => shorturl
                                             shorturl
                                              |----> unordered_map (In memory)
                                              |----> file (on disk)
        </code></pre>

        <h5>10 M Users</h5>
        <dl>
        Generating short-url for Long-url. There are 2 methods:<br>
        a. Runtime: As we get request, generate short-url. This makes system slow.<br>
        b. Offline(We take this): Fast. <a href=#kgs">KGS</a> will keep generating shorturls offline and keep pushing on DB.
        </dl>
        <image style="width:400px;height: 500px;"
        src="//www.plantuml.com/plantuml/png/VP91Yzim48Nlyok6pQK5xw65zc2wORUxi8MKGicXz5H6zaGIjYKZoMrSykDhHLOIWsakGM--b_T6ogCFvCBGjT1FtxhIFPc0mja_dXsIHm727l7kXG9LR0AxEzpi53KQyDRnrFTxTh-JX_no-4oLuZYebleNykgL3JiAzcnKSWdiU9pdsfhzw0Dt4Mla551J846USV_zww-Npr6l1R2fSIeCO6nWjB5GXPldaGpWfvXNe5TssjYrspCSkLjQoOotriW9kzy28fxUV_WOxQTqZ9zuNFk9M0ytJty7np2tPu_GyEWVSZROmw7LXjVySOqvky1bvGA3xjWEuSOdy7wBvClS5yX7HSchecHcLEoSWAh4sh8_IyX7xGDK6Vl9_atEV3lpeiGiNS5l5j8uBbscAu56ve1iMBx6gsrh-E5quA2S7QHAVn3up_jS0XDpGL9uBL9qaJTUkR67TpWokPLbu77A6Rhs7m00"/>
        <pre class="puml" visibility: hidden>
          @startuml
          participant browser as b
          box "Datacenter" #Khaki
           participant AppServer as as
           participant Cache as c
           participant HashGenerator as hg
           participant KeyGenerationSystem as kgs
           database SQL_DB as db
          end box
          
          note over c #Cyan
           <Hash, shorturl>
          end note
          
          note over hg #Cyan
           longurl->
             |256Hash|->
                 Hash
          end note
          
          note over kgs #Azure
          Generates 
          keys=shorturl
          offline
          end note
          
          note over db
          longurl, Hash, shorturl, timeout
          end note
          
          b -> as: longurl
          as -> hg: longurl
          hg -> as: hash
          as -> c: does hash exist
          c -> as: Yes(shorturl)
          as -> b: shorturl
          c -> as: No
          
          as -> kgs: Hash
          
          kgs -> c: shorturl
          note over c #Gold
          Writethrough Cache
          <Hash, shorturl>
          end note
          
          c -> as: <Hash,shorturl>
          as ->db: Hash, longurl, shorturl, timeout=1 year
          as -> b: shorturl
          
          @enduml          
        </pre>

        <h3 id="kgs">Key Generating System</h3>
        <dl><strong>Only 8 character shorturl would be generated</strong></dl>
        <dd>
          For 8 character short URL. Total possible combinations: 64<sup>8</sup> = 2.8 x 1014 = 280 Trillion. //Huge Enough
        </dd>
        <pre><code class="language-css">
1. Get Hash of long URL
long-url > |SHA3 or MD5 Hash|  > XXX

2. Convert 128bit(16 bytes=16 characters) hash to (Base 64 Format = 8 characters)
Return 1st 8 characters from 21 characters.
Problem: Differnt long URL's can produce same 1st 8 characters.
Solution: Append timestamp or userId with longURL and then generate the short url
        </code></pre>

    </article>
  </main>

  <script src="/scripts/prism.js"></script>
</body>
</html>

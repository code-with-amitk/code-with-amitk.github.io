<!DOCTYPE html>
<html>
<head>
    <title>Single Number II</title>
    <link rel="stylesheet" href="/css/styles.css"/>
</head>

<body>
    <nav class="navbar">    <!--See .navbar in styles.css-->
        <ul>
          <li><a href="/">Home</a></li>
          <li><a href="#">Our team</a></li>
          <li><a href="#">Projects</a></li>
          <li><a href="/contact.html">Contact</a></li>
          <li>
            <form id="searchForm">
                <input type="search" id="searchInput" name="q" placeholder="Search site" />
                <input type="submit" value="Go!" />
            </form>
           </li>
        </ul>
    </nav>
    <aside class="sidebar">    <!--See .sidebar in styles.css-->
        <a href="#problem">Problem</a>
        <a href="#a1">Approach-1, unordered_map, Count Frequency. Time:O(n), Space:O(m)</a>
        <a href="#a2">Approach-2, unordered_set, Time:O(n), Space:O(m)</a>
        <a href="#a3">Approach-3. minHeap. Time:O(n). Space:O(n)</a>
        <a href="#a4">Approach-4. Sort. Time:O(nlogn). Space:O(1)</a>
        <a href="#a5">Approach-5, Using Bitwise Operators, Time:O(n), Space:O(1)</a>
        </ul>
    </aside>

    <div style="margin-left:200px;">
        <h2 id="problem"><a href="https://leetcode.com/problems/single-number-ii/description/">
            137. Single Number II</a></h2>
        <dl>
            Given an integer array nums where every element appears three times except for one, 
            which appears exactly once. Find the single element and return it. 
            You must implement a solution with a linear runtime complexity and use only 
            constant extra space.
        </dl>
        <pre><code>
            Example 1:
            Input: nums = [2,2,3,2]
            Output: 3
    
            Example 2:
            Input: nums = [0,1,0,1,0,1,99]
            Output: 99
        </code></pre>

        <h2 id="a5">Approach-5, Using Bitwise Operators, Time:O(n), Space:O(1)</h2>
        <h3>Logic</h3>
        <pre><code>
            - _1._ Sum all the bits in same positions for all the elements in `int bitset[32]`
            ```c
            input = {6, 6, 6, 3}   
            
            6 -> 00000000 00000000 00000000 00000 110
            6 -> 00000000 00000000 00000000 00000 110
            6 -> 00000000 00000000 00000000 00000 110
            3 -> 00000000 00000000 00000000 00000 011
              ________________________________________+
                    0       0         0     00000 341
            ```
            - _2._ Take modulus by 3. We can mod by n which means elements repeating n times.
            ```c
            0mod3 3mod3  4mod3 1mod3
            _________________________
            0       0     1     1         =>   3  appearing once.
            ```
        </code></pre>

        <h3>Complexity</h3>
        <h4>Time</h4>
            <dl>O(n)</dl>
        <h4>Space:O(1)</h4>
            <dl>We are taking bitset of size 32 all times</dl>

        <h3>Code</h3>
        <div class="tab">
            <button class="tablinks" onclick="opencode(event, 'cpp98')">CPP98</button>
            <button class="tablinks" onclick="opencode(event, 'cpp11')">CPP11</button>
            <button class="tablinks" onclick="opencode(event, 'python')">Python</button>
        </div>
    
        <!-- Tab content -->
        <div id="cpp98" class="tabcontent">
            <h4>CPP98</h4>
            <pre><code>
                class Solution {
                    public:
                        int singleNumber(vector<int>& nums) {
                            const int size = 33;
                            std::vector<int> bitarray(size, 0);
                    
                            // Find bits in 32 bit integer
                            // nums = {6,6,6,3}
                            // bitarray = {0,4,1,3,0,0,0,0,..}
                            for (const auto&num : nums) {
                                int k = abs(num);
                                
                                uint64_t j = 0, a = 1;
                                while (j++ < size) {
                                    int val = k & a;
                                    if (val)
                                        bitarray[j]++;
                                    a <<= 1;
                                }
                            }
                          
                            // bitarray%3
                            for (auto&i : bitarray)
                                i %= 3;
                    
                            // Find number
                            uint64_t u64Out = 0;
                            for (int i=1;i<size;++i) {
                                if (bitarray[i])
                                    u64Out += pow(2, i-1);
                            }
                    
                            ////////Handling -ve Number {1,1,-2,1}/////////
                            //We have taken abs of all numbers before. {1,1,-2,1} => {1,1,2,1}
                            //With above logic answer=2.
                            //Check back again in input array, that 2 exists? if not answer=-2
                            int count = 0;
                            for (auto num:nums) {
                                if (num == u64Out)
                                    count++;
                            }
                            return count==1 ? u64Out : -u64Out;
                        }
                    };
                </code></pre>
        </div>
    
        <div id="cpp11" class="tabcontent">
            <h4>CPP11</h4>
            <pre><code>
                class Solution {
                    public:
                        int singleNumber(vector<int>& nums) {
                            const int size = 33;
                            std::vector<int> bitarray(size, 0);
                    
                            // Find bits in 32-bit integer
                            // lambda function
                            // for_each (InputIterator start_iter, InputIterator last_iter, Function fnc)
                            // Lambda captures the bitarray vector and size variable by reference (&) from env
                            std::for_each(nums.begin(), nums.end(), [&bitarray, size](const auto& num) {
                                const int k = std::abs(num);
                                uint64_t j = 0, a = 1;
                                while (j++ < size) {
                                    const int val = k & a;
                                    if (val)
                                        bitarray[j]++;
                                    a <<= 1;
                                }
                            });
                    
                            // bitarray % 3
                            for (auto& i : bitarray)
                                i %= 3;
                    
                            // Find number
                            uint64_t u64Out = 0;
                            for (int i = 1; i < size; ++i) {
                                if (bitarray[i])
                                    u64Out += std::pow(2, i - 1);
                            }
                    
                            // // Handling negative numbers
                            return std::count(nums.begin(), nums.end(), u64Out)==1 ? u64Out : -u64Out;
                        }
                    };
                </code></pre>
        </div>
    
        <div id="python" class="tabcontent">
            <h4>Python</h4>
            <pre><code>
                class Solution:
                def singleNumber(self, nums: List[int]) -> int:
                    size = 33
                    bitarray = [0] * size
            
                    # Find bits in a 32-bit integer
                    for num in nums:
                        k = abs(num)
                        j = 0
                        a = 1
                        while j < size:
                            if k&a:
                                bitarray[j] += 1
                            a <<= 1
                            j += 1
            
                    # bitarray % 3
                    for i in range(len(bitarray)):
                        bitarray[i] %= 3
            
                    # Find number
                    u64Out = 0
                    for i in range(1, size):
                        if bitarray[i]:
                            u64Out += 2 ** (i - 1)
            
                    # Handling negative numbers {1,1,-2,1}
                    # We have taken the absolute value of all numbers before: {1,1,2,1}
                    # With the above logic, the answer would be 2
                    # Check back again in the input array if 2 exists, if not, answer = -2
                    count = 0
                    for num in nums:
                        if num == u64Out:
                            count += 1
            
                    return u64Out if count == 1 else -u64Out
                </code></pre>
            </div>
    </div>

    <script src="/scripts/common.js"></script>
</body>

</html>

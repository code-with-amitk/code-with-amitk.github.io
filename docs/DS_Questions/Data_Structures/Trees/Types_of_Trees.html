<!DOCTYPE html>
<html>
<head>
    <title>Binary Trees</title>
    <link rel="stylesheet" href="/css/styles.css"/>
    <link rel="stylesheet" href="/css/prism.css"/>
</head>

<body>
    <nav class="navbar">    <!--See .navbar in styles.css-->
        <ul>
          <li><a href="/">Home</a></li>
          <li><a href="#">Our team</a></li>
          <li><a href="#">Projects</a></li>
          <li><a href="#">Contact</a></li>
          <li>
            <form>
                <input type="search" name="q" placeholder="Search site" />
                <input type="submit" value="Go!" />
            </form>
           </li>
        </ul>
    </nav>

    <aside class="sidebar">    <!--See .sidebar in styles.css-->
        <a href="#treetypes">Types of Trees</a>
        <ul>
            <li><a href="#binarytree">Binary Trees</a></li>
            <li><a href="#binarysearchtree">Binary Search Trees</a></li>
                <ul>
                    <li><a href="#avltree">AVL Trees</a></li>
                    <li><a href="#redblacktree">Red Black Trees</a></li>
                    <li><a href="#btree">BTrees</a></li>
                </ul>
            <li><a href="#trie">Trie</a></li>
            <li><a href="#heap">Heap</a></li>
            <li><a href="#ternarysearchtree">Ternary Search Tree</a></li>
            <li><a href="#splaytree">Splay Tree</a></li>
            <li><a href="#suffixtree">Suffix Tree</a></li>
        </ul>
        
        
    </aside>

    <main>
        <article style="margin-left:200px;">
            <h2 id="treetypes">Types of Trees</h3>
            <h3 id="binarytree">1. Binary Trees</h3>
            <p>
                Each node has at most 2 children.<br>
                Height = log2n for n number of nodes.
            </p>
            <h4>Types of Binary Trees</h4>
            <dl><strong>1. Full / Proper BT / 2-Tree</strong></dl>
            <p>Every node have 0 or 2 children. No node have 1 child</p>
            <pre>

        a
       /  \
     b      c
    /  \
  d     e
            </pre>  

            <dl><strong>2. Complete BT</strong></dl>
            <p>All levels are completely filled except last.</p>
            <pre>

            a                        a [Not CT]
           /   \                    /
         b      c                  b
      /    \    /                 /
     d     e    f                c
            </pre>

            <dl><strong>3. Perfect Tree</strong></dl>
            <p>A full & complete BT. All leaves at same level.</p>
            <pre>
        a(Perfect)         a(not perfect)
      /    \              /\
    b       c            b  c
  /  \     /  \         /\  /
            </pre>

            <dl><strong>4. Balanced BT</strong></dl>
            <p>
            In a balanced binary tree, the height of the left and the right subtrees of each node should vary by at most one. <br>
            Eg: AVL Tree and a Red-Black Tree
            </p>

            <dl><strong>5. Degenerate / Pathological BT</strong></dl>
            <p>Every internal node has only a single child. Such trees are similar to a linked list performance-wise.</p>
            <pre>
                a
               /
              b
             /
            c
             \
               d
            </pre>

            <dl><strong>6. Rope / Cord</strong></dl>
            <p>
            BT where:<br>
                non-leaf node holds   : sum of lengths of all leaves in left subtree<br>
                leaf node holds       : string+length(also called weight)
            </p>
            <pre>
Storing: "Hello_my_name_is_Amit"
H e l l o _ m y _ n a m e _ i s _ A m i t
0 1 2 3 4 5 6 7 8 9 1011121314151617181920

                        21
                      /    
                    9
               /         \
              6             6
            /   \        /      \
     Hello_,6  my_,3    2          1
                      /   \      /    \
                  na,2  me_i,4  s,1   _Amit,5 
            </pre>
            <p>
            Advatanges:<br>
            1. Used for efficient storage and manipulation a very long string.<br>
            2. Unlike arrays, ropes do not require large contiguous memory allocations.<br>
            3. Time Complexity (for insertion/deletion/searching) is O(logn) unlike strings which is O(n). Hence its VERY IMPORTANT TO LEARN.<br>
            Disadvatanges:<br>
            1. Complex code<br>
            2. Extra memory required to store parent nodes.<br>
            3. Time to access ith character increases. In plain strings its O(1).
            </p>

            <h3 id="binarysearchtree">2. Binary Search Trees (BST)</h3>
            <p>
                - Mainly used for Searching. Duplicate elements cannot exist. 
                - Left-child &lt; parent, right-child > parent. Insert/search/delete: O(log(n))
            </p>
            <pre>
             2
            /  \
            1   3
            </pre>
            <h4>Types of Binary Search Trees</h4>
            <dl><strong>1. Self Balanced / Height Balanced BST(HBT)</strong></dl>
            <p>
                - HBT always keeps itself balanced by rotation if its <b>Balancing Factor</b> is not equal to -1,0,1.<br>
                - BF = Right_Height - Left_Height.    //if bf>2 rotation is needed<br>
                - <b>Complexities:</b> Insert/delete/search O(logn) even in worst case
            </p>
            <p>
            <b>Problem with BST?</b><br>
                BST may not be balanced all times, BF depends on incoming data in Real time. 
            </p>
            <pre>
[t = 1. data=9]
[t=2 data=8]
[t=3 data=7]. Instead of BST linear array is created.
                9
                /
              8
            /
          7

Not Balanced. Need rotation at this node          
          3 (bf:-2)
          /
         2(bf:-1)
        /
       1(bf:0)

HBT
                  5(bf: -1)
                 /  \
       (bf: -1)4      6(bf: 0)
              /
              3(bf: 0)
            </pre>

            <dt id="avltree"><strong>1a. AVL Tree (Adelson-Velsky and Landis)</strong></dt>
            <p>
                Rotation Examples in AVL Tree
                a. Left & right rotation: Similarly we can perform right,left rotation.                
            </p>
            <pre>
                6              6
                /              /
               3     -->      4    -->      4
                \            /            /   \
                 4          3            3     6                
            </pre>

            <dt id="redblacktree"><strong>1b. Red-Black Tree</strong></dt>
            <p>Each node have color(red or black).</p>
            <pre>
                struct node{ 
                    int item;  
                    enum{red, black}color;
                    struct node *parent, *left, *right; 
                  };
                  
                                          |
                      |item|color|*left|*parent|*right|
                                  /                 \                
            </pre>
            <dd><strong>Creating RBT</strong></dd>
            <p>
                - Node is inserted based on bst if (node>root) right else left. After insertion Rules to check RBT.<br>
                - Rules of Insertion<br>
                    1. If tree is empty add a black node.<br>
                    2. Insert new leaf node as Red.<br>
                    2a. 2 adjacent Red Nodes
            </p>

            <pre>
                Create RBT using 1,2,3,4,5,6,7,8

                Rule-1     Rule-2      Rule-2
                1,B   ->    1,B          1,B
                             \     ->     \
                              2,R          2,R
                                            \
                                             3,R //Voilates a. Two adjacent
                                                   Red not allowed. 
            </pre>

            <dt><strong>Rules to check RBT or Not?</strong></dt>
            <p>
            a. Each node has color either red or black.<br>
            b. Root is always black.<br>
            c. 2 adjacent red nodes Not Allowed. 2 adjacent black nodes allowed. ie No Red-Red parent child relationship.<br>
            d. Every path from a node to its leaf NULL child has the same number of black nodes.<br>
            e. Add null children at leaf. null children are always black(But donot consider null while considering rule-d).
            </p>
            <pre>
                B(not RBT                  B(RBT)              B(not RBT, violates rule-c)
                /  violates rule-d)       /    \               /
                B                        R      B             R
               /                        / \    /               \
              B                        B  B  R                  R
            </pre>

            <dt id="btree"><strong>1c. BTree / B Tree / B-Tree (Fat Tree)</strong></dt>
            <p>
                - Sorted self-balancing search tree (might not be binary). Nodes can have more than 1 children. 
                <b>This makes BTree a Fat Tree</b>
            </p>
            <p>
                <b>Fat Tree?</b><br>
                - Most of data on same level. Hence depth of tree is less wrt BST & makes efficient wrt BST
            </p>
            <p>
                - Each node contain B-1 to 2B-1 elements in a contiguous array, 
                hence we need not allocate every time element is inserted & improve cache efficiency.<br>
                - Searching might become linear but its better wrt BST.<br>
                - BTree is used to store huge amount of data that cannot fit in main memory. (Eg: DB)<br>
                - BTree is better wrt Disk Access: Since DB uses B-Tree/B+Tree. Search time is still better than disk.<br>
                - <b>Time complexity(Search, Insert, Delete):</b> O(log n). n is no of nodes.
            </p>
            <pre>
                struct btree{
                    int *keys;  // An array of keys
                    int t;      // Minimum degree (defines the range for number of keys)
                    BTreeNode **C; // An array of child pointers
                    int n;     // Current number of keys
                    bool leaf; // Is true when node is leaf. Otherwise false
                }                    
            </pre>

            <h3 id="trie">3. Trie (Prefix Tree) / Prefix tree / Digital search tree / Retrieval tree</h3>
            <p>
                Trie is variant of an n-arytree in which characters are stored at each node. Each path down the tree may represent a word.<br>
                Null nodes or * Nodes: are often used to indicate complete words.
            </p>
            <p>
                <b>Usage of Trie</b><br>
                - Trie is used to store the entire (English) language for quick prefix lookups. <br>
                - It can tell us if a string is a prefix of any valid words.<br>
                - Data structure used for efficient storage/retrieval/deletion of strings.
            </p>
            <img src="/images/trie.JPG" alt="trie" style="width:100px;height:70px;">

            <h3 id="heap">4. Heap / Binary heap / Balanced Complete BT / Priority Queue</h3>
            <p>
                - Each element is given a priority. Higher priority element is processed before any lower priority element.<br>
                - Duplicates are allowed. This is suited to be stored in array ie Heap can be implemented using arrays. 
                If you use arrays to implement Heaps then you don’t need to store pointer as done in trees and its 
                space advantage
            </p>
            <p>
                <b>Complexities</b><br>
                Insert: O(logn), Search: O(1), Delete: O(logn)
            </p>

            <h4>Types of Heap</h4>
            
            <dl><strong>4a. Max Heap</strong></dl>
            <p>
                Root is always greatest. parent >= child<br>
                2nd, 3rd largest element are direct children of root(either left or right).                
            </p>
            <dt><strong>Creation</strong></dt>
            <p>
                Traverse array and create Level-Order tree.<br>
                Heapify only non-leaf nodes. Indexes of non-leaf nodes = 0 to (N/2 - 1)<br>
                Heapfiy a node means, exchange node with either left or right child who is greatest and do till leaf node                
            </p>
            <pre>
                a[] = {1, 3, 5, 4, 6, 13}
                N=6. N/2-1 = 2. Need to heapify elements at index=0,1,2. Start from index=2
                
                     1            1
                    / \           / \
                   3   5  =>     6   5
                  / \   /       /\  /
                  4  6 13      4 3  13
                Heapify=3
                
                   1            1
                  / \          /  \
                 6   5   =>   6    13
                / \  /       / \   /
                3 4 13      3  4   5
                Heapify 5
                
                   1             13         13
                  / \           /  \       /  \
                 6   13   =>   6    1  =>  6   5
                / \  /        / \   /     / \  /
                3 4 5        3  4  5     3  4  1
                Heapify 1
                
                - Max Heap of `pairs<key, value>`: Elements are sorted as per values.
                 <2,gggg> <2,bb> <2,c> <2,aaaa>
                
                          <2,gggg>
                          /       \
                       <2,bb>     <2,c>
                       /
                    <2,a>                
            </pre>
            <dt><strong>Insertion = O(logn)</strong></dt>
            <p>Always insert element at bottom rightmost spot so as to maintain the complete tree property.</p>
            <pre>
                Insert 10
                13                  13
               /  \                /  \
              6    5      =>      6   10
             / \   / \           / \   /\
            3  4  1  10         3  4  1  5
              Swap 5,10       Until 10 finds correct spot
            
            a[] = {13,6,5,3,4,1,10}. N=7. N/2-1 = 2. Heapify=0,1,2. Start from element at index=2
            
                 13              13
                /  \            /  \
               6    5    =>    6    10
              / \  / \        / \   / \
             3  4  1  10     3   4  1  5
              Heapfiy 5.  index=2 heapified
            
              index=1 a[1]=6. Donot need heapification
              index=0 a[0]=13. Donot need heapification                
            </pre>
            <dt><strong>Delete = O(logn)</strong></dt>
            <pre>
                Delete root
                13
               /  \
              6    10
             / \   / \
            3   4  1  5
          
          Step-1. Replace last leaf node with root & Delete last node
                5                5
               /  \             /  \
              6    10    =>    6    10
             / \   / \        /  \  /
            3   4  1  13     3   4  1
          
          Heapify non-leaf nodes (5,6,10)
          10,6 donot need heapification
          
                5            10
               /  \         /  \
              6   10  =>   6    5
             / \  /       / \   /
            3  4  1      3  4  1
            Heapify 5                
            </pre>


            <dl><strong>4b. Min Heap</strong></dl>
            <p>Root is always least. Condition: parent =< child. Heapify only non-leaf nodes</p>

            <h3 id="ternarysearchtree">5. Ternary Search Tree</h3>
            <p>
                A tree data structure used for storing a dictionary of words where each node represents a character.<br>
                Allows for efficient searching, insertion, and deletion of strings.
            </p>

            <h3 id="splaytree">6. Splay Tree</h3>
            <p>
                A self-adjusting binary search tree where recently accessed elements are moved to the root to optimize future accesses.<br>
                Typically used in scenarios where data access is not uniform.
            </p>

            <h3 id="suffixtree">7. Suffix Tree and Suffix Array</h3>
            <p>
                Data structures used for efficient substring search in a string or document.<br>
                Used in string processing and bioinformatics applications
            </p>

        </article>
    </main>

    <script src="/scripts/prism.js"></script>
</body>

</html>

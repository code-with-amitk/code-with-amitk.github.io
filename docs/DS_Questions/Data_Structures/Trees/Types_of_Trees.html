<!DOCTYPE html>
<html>
<head>
    <title>Binary Trees</title>
    <link rel="stylesheet" href="/css/styles.css"/>
    <link rel="stylesheet" href="/css/prism.css"/>
</head>

<body>
    <nav class="navbar">    <!--See .navbar in styles.css-->
        <ul>
          <li><a href="/">Home</a></li>
          <li><a href="#">Our team</a></li>
          <li><a href="#">Projects</a></li>
          <li><a href="#">Contact</a></li>
          <li>
            <form>
                <input type="search" name="q" placeholder="Search site" />
                <input type="submit" value="Go!" />
            </form>
           </li>
        </ul>
    </nav>

    <aside class="sidebar">    <!--See .sidebar in styles.css-->
        <a href="#treetypes">Types of Trees</a>
        <ul>
            <li><a href="#binarytree">Binary Trees</a></li>
            <li><a href="#binarysearchtree">Binary Search Trees</a></li>
                <ul>
                    <li><a href="#avltree">AVL Trees</a></li>
                    <li><a href="#redblacktree">Red Black Trees</a></li>
                    <li><a href="#btree">BTrees</a></li>
                </ul>
            <li><a href="#trie">Trie</a></li>
            <li><a href="#heap">Heap</a></li>
            <li><a href="#ternarysearchtree">Ternary Search Tree</a></li>
            <li><a href="#splaytree">Splay Tree</a></li>
            <li><a href="#suffixtree">Suffix Tree</a></li>
        </ul>
        
        
    </aside>

    <main>
        <article style="margin-left:200px;">
            <h2 id="treetypes">Types of Trees</h3>
            <h3 id="binarytree">1. Binary Trees</h3>
            <p>
                Each node has at most 2 children.<br>
                Height = log2n for n number of nodes.
            </p>
            <h4>Types of Binary Trees</h4>
            <dl><strong>1. Full / Proper BT / 2-Tree</strong></dl>
            <p>Every node have 0 or 2 children. No node have 1 child</p>
            <pre>

        a
       /  \
     b      c
    /  \
  d     e
            </pre>  

            <dl><strong>2. Complete BT</strong></dl>
            <p>All levels are completely filled except last.</p>
            <pre>

            a                        a [Not CT]
           /   \                    /
         b      c                  b
      /    \    /                 /
     d     e    f                c
            </pre>

            <dl><strong>3. Perfect Tree</strong></dl>
            <p>A full & complete BT. All leaves at same level.</p>
            <pre>
        a(Perfect)         a(not perfect)
      /    \              /\
    b       c            b  c
  /  \     /  \         /\  /
            </pre>

            <dl><strong>4. Balanced BT</strong></dl>
            <p>
            In a balanced binary tree, the height of the left and the right subtrees of each node should vary by at most one. <br>
            Eg: AVL Tree and a Red-Black Tree
            </p>

            <dl><strong>5. Degenerate / Pathological BT</strong></dl>
            <p>Every internal node has only a single child. Such trees are similar to a linked list performance-wise.</p>
            <pre>
                a
               /
              b
             /
            c
             \
               d
            </pre>

            <dl><strong>6. Rope / Cord</strong></dl>
            <p>
            BT where:<br>
                non-leaf node holds   : sum of lengths of all leaves in left subtree<br>
                leaf node holds       : string+length(also called weight)
            </p>
            <pre>
Storing: "Hello_my_name_is_Amit"
H e l l o _ m y _ n a m e _ i s _ A m i t
0 1 2 3 4 5 6 7 8 9 1011121314151617181920

                        21
                      /    
                    9
               /         \
              6             6
            /   \        /      \
     Hello_,6  my_,3    2          1
                      /   \      /    \
                  na,2  me_i,4  s,1   _Amit,5 
            </pre>
            <p>
            Advatanges:<br>
            1. Used for efficient storage and manipulation a very long string.<br>
            2. Unlike arrays, ropes do not require large contiguous memory allocations.<br>
            3. Time Complexity (for insertion/deletion/searching) is O(logn) unlike strings which is O(n). Hence its VERY IMPORTANT TO LEARN.<br>
            Disadvatanges:<br>
            1. Complex code<br>
            2. Extra memory required to store parent nodes.<br>
            3. Time to access ith character increases. In plain strings its O(1).
            </p>

            <h3 id="binarysearchtree">2. Binary Search Trees (BST)</h3>
            <p>
                - Mainly used for Searching. Duplicate elements cannot exist. 
                - Left-child &lt; parent, right-child > parent. Insert/search/delete: O(log(n))
            </p>
            <pre>
             2
            /  \
            1   3
            </pre>
            <h4>Types of Binary Search Trees</h4>
            <dl><strong>1. Self Balanced / Height Balanced BST(HBT)</strong></dl>
            <p>
                - HBT always keeps itself balanced by rotation if its <b>Balancing Factor</b> is not equal to -1,0,1.<br>
                - BF = Right_Height - Left_Height.    //if bf>2 rotation is needed<br>
                - <b>Complexities:</b> Insert/delete/search O(logn) even in worst case
            </p>
            <p>
            <b>Problem with BST?</b><br>
                BST may not be balanced all times, BF depends on incoming data in Real time. 
            </p>
            <pre>
[t = 1. data=9]
[t=2 data=8]
[t=3 data=7]. Instead of BST linear array is created.
                9
                /
              8
            /
          7

Not Balanced. Need rotation at this node          
          3 (bf:-2)
          /
         2(bf:-1)
        /
       1(bf:0)

HBT
                  5(bf: -1)
                 /  \
       (bf: -1)4      6(bf: 0)
              /
              3(bf: 0)
            </pre>

            <dt id="avltree"><strong>1a. AVL Tree (Adelson-Velsky and Landis)</strong></dt>
            <p>
                Rotation Examples in AVL Tree
                a. Left & right rotation: Similarly we can perform right,left rotation.                
            </p>
            <pre>
                6              6
                /              /
               3     -->      4    -->      4
                \            /            /   \
                 4          3            3     6                
            </pre>

            <dt id="redblacktree"><strong>1b. Red-Black Tree</strong></dt>
            <p>Each node have color(red or black).</p>
            <pre>
                struct node{ 
                    int item;  
                    enum{red, black}color;
                    struct node *parent, *left, *right; 
                  };
                  
                                          |
                      |item|color|*left|*parent|*right|
                                  /                 \                
            </pre>
            <dd><strong>Creating RBT</strong></dd>
            <p>
                - Node is inserted based on bst if (node>root) right else left. After insertion Rules to check RBT.<br>
                - Rules of Insertion<br>
                    1. If tree is empty add a black node.<br>
                    2. Insert new leaf node as Red.<br>
                    2a. 2 adjacent Red Nodes
            </p>

            <pre>
                Create RBT using 1,2,3,4,5,6,7,8

                Rule-1     Rule-2      Rule-2
                1,B   ->    1,B          1,B
                             \     ->     \
                              2,R          2,R
                                            \
                                             3,R //Voilates a. Two adjacent
                                                   Red not allowed. 
            </pre>

            <dt><strong>Rules to check RBT or Not?</strong></dt>
            <p>
            a. Each node has color either red or black.<br>
            b. Root is always black.<br>
            c. 2 adjacent red nodes Not Allowed. 2 adjacent black nodes allowed. ie No Red-Red parent child relationship.<br>
            d. Every path from a node to its leaf NULL child has the same number of black nodes.<br>
            e. Add null children at leaf. null children are always black(But donot consider null while considering rule-d).
            </p>
            <pre>
                B(not RBT                  B(RBT)              B(not RBT, violates rule-c)
                /  violates rule-d)       /    \               /
                B                        R      B             R
               /                        / \    /               \
              B                        B  B  R                  R
            </pre>

            <dt id="btree"><strong>1c. BTree / B Tree / B-Tree (Fat Tree)</strong></dt>
            <p>
                - Sorted self-balancing search tree (might not be binary). Nodes can have more than 1 children. 
                <b>This makes BTree a Fat Tree</b>
            </p>
            <p>
                <b>Fat Tree?</b><br>
                - Most of data on same level. Hence depth of tree is less wrt BST & makes efficient wrt BST
            </p>
            <p>
                - Each node contain B-1 to 2B-1 elements in a contiguous array, 
                hence we need not allocate every time element is inserted & improve cache efficiency.<br>
                - Searching might become linear but its better wrt BST.<br>
                - BTree is used to store huge amount of data that cannot fit in main memory. (Eg: DB)<br>
                - BTree is better wrt Disk Access: Since DB uses B-Tree/B+Tree. Search time is still better than disk.<br>
                - <b>Time complexity(Search, Insert, Delete):</b> O(log n). n is no of nodes.
            </p>
            <pre>
                struct btree{
                    int *keys;  // An array of keys
                    int t;      // Minimum degree (defines the range for number of keys)
                    BTreeNode **C; // An array of child pointers
                    int n;     // Current number of keys
                    bool leaf; // Is true when node is leaf. Otherwise false
                }                    
            </pre>

            <h3 id="trie">3. Trie (Prefix Tree) / Prefix tree / Digital search tree / Retrieval tree</h3>
            <p>
                Trie is variant of an n-arytree in which characters are stored at each node. Each path down the tree may represent a word.<br>
                Null nodes or * Nodes: are often used to indicate complete words.
            </p>
            <p>
                <b>Usage of Trie</b><br>
                - Trie is used to store the entire (English) language for quick prefix lookups. <br>
                - It can tell us if a string is a prefix of any valid words.<br>
                - Data structure used for efficient storage/retrieval/deletion of strings.
            </p>
            <img src="/images/trie.JPG" 
            alt="trie" style="width:100px;height:70px;">

            <h3 id="heap">4. Heap / Binary heap / Balanced Complete BT / Priority Queue</h3>
            <p>
                - Each element is given a priority. Higher priority element is processed before any lower priority element.<br>
                - Duplicates are allowed. This is suited to be stored in array ie Heap can be implemented using arrays. 
                If you use arrays to implement Heaps then you donâ€™t need to store pointer as done in trees and its 
                space advantage
            </p>
            <p>
                <b>Complexities</b><br>
                Insert: O(logn), Search: O(1), Delete: O(logn)
            </p>

            <h4>Types of Heap</h4>
            
            <dl><strong>4a. Max Heap</strong></dl>
            <p>
                Root is always greatest. parent >= child<br>
                2nd, 3rd largest element are direct children of root(either left or right).                
            </p>
            <dt><strong>Creation</strong></dt>
            <p>
                Traverse array and create Level-Order tree.<br>
                Heapify only non-leaf nodes. Indexes of non-leaf nodes = 0 to (N/2 - 1)<br>
                Heapfiy a node means, exchange node with either left or right child who is greatest and do till leaf node                
            </p>
            <pre>
                a[] = {1, 3, 5, 4, 6, 13}
                N=6. N/2-1 = 2. Need to heapify elements at index=0,1,2. Start from index=2
                
                     1            1
                    / \           / \
                   3   5  =>     6   5
                  / \   /       /\  /
                  4  6 13      4 3  13
                Heapify=3
                
                   1            1
                  / \          /  \
                 6   5   =>   6    13
                / \  /       / \   /
                3 4 13      3  4   5
                Heapify 5
                
                   1             13         13
                  / \           /  \       /  \
                 6   13   =>   6    1  =>  6   5
                / \  /        / \   /     / \  /
                3 4 5        3  4  5     3  4  1
                Heapify 1
                
                - Max Heap of `pairs<key, value>`: Elements are sorted as per values.
                 <2,gggg> <2,bb> <2,c> <2,aaaa>
                
                          <2,gggg>
                          /       \
                       <2,bb>     <2,c>
                       /
                    <2,a>                
            </pre>
            <dt><strong>Insertion = O(logn)</strong></dt>
            <p>Always insert element at bottom rightmost spot so as to maintain the complete tree property.</p>
            <pre>
                Insert 10
                13                  13
               /  \                /  \
              6    5      =>      6   10
             / \   / \           / \   /\
            3  4  1  10         3  4  1  5
              Swap 5,10       Until 10 finds correct spot
            
            a[] = {13,6,5,3,4,1,10}. N=7. N/2-1 = 2. Heapify=0,1,2. Start from element at index=2
            
                 13              13
                /  \            /  \
               6    5    =>    6    10
              / \  / \        / \   / \
             3  4  1  10     3   4  1  5
              Heapfiy 5.  index=2 heapified
            
              index=1 a[1]=6. Donot need heapification
              index=0 a[0]=13. Donot need heapification                
            </pre>
            <dt><strong>Delete = O(logn)</strong></dt>
            <pre>
                Delete root
                13
               /  \
              6    10
             / \   / \
            3   4  1  5
          
          Step-1. Replace last leaf node with root & Delete last node
                5                5
               /  \             /  \
              6    10    =>    6    10
             / \   / \        /  \  /
            3   4  1  13     3   4  1
          
          Heapify non-leaf nodes (5,6,10)
          10,6 donot need heapification
          
                5            10
               /  \         /  \
              6   10  =>   6    5
             / \  /       / \   /
            3  4  1      3  4  1
            Heapify 5                
            </pre>


            <dl><strong>4b. Min Heap</strong></dl>
            <p>Root is always least. Condition: parent =< child. Heapify only non-leaf nodes</p>

            <h3 id="ternarysearchtree">5. Ternary Search Tree</h3>
            <p>
                A tree data structure used for storing a dictionary of words where each node represents a character.<br>
                Allows for efficient searching, insertion, and deletion of strings.
            </p>

            <h3 id="splaytree">6. Splay Tree</h3>
            <p>
                A self-adjusting binary search tree where recently accessed elements are moved to the root to optimize future accesses.<br>
                Typically used in scenarios where data access is not uniform.
            </p>

            <h3 id="suffixtree">7. Suffix Tree and Suffix Array</h3>
            <p>
                Data structures used for efficient substring search in a string or document.<br>
                Used in string processing and bioinformatics applications
            </p>

        </article>
    </main>

    <script src="/scripts/prism.js"></script>
</body>

</html>

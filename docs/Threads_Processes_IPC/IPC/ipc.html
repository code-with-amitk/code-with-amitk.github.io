<!DOCTYPE html>
<html>
<head>
    <title>IPC</title>
    <link rel="stylesheet" href="/css/styles.css"/>
    <link rel="stylesheet" href="/css/prism.css" />
    <!-- Add any necessary CSS and JavaScript files -->
</head>
<body>
    <nav class="navbar">    <!--See .navbar in styles.css-->
        <ul>
          <li><a href="/">Home</a></li>
          <li><a href="#">Our team</a></li>
          <li><a href="#">Projects</a></li>
          <li><a href="/contact.html">Contact</a></li>
          <li>
            <form id="searchForm">
                <input type="search" id="searchInput" name="q" placeholder="Search site" />
                <input type="submit" value="Go!" />
            </form>
           </li>
        </ul>
    </nav>

    <aside class="sidebar">    <!--See .sidebar in styles.css-->
        
    </aside>

    <main>  <!--Here is our page's main content-->

        <div style="margin-left:200px;">
            <h2 id="code">IPC</h2>
            <div class="tab">
                <button class="tablinks" onclick="opencode(event, 'rustchannel')">Rust (Channels)</button>
                <!--
                <button class="tablinks" onclick="opencode(event, 'cppfunctor')">CPP(Functor)</button>
                <button class="tablinks" onclick="opencode(event, 'rust')">Rust</button>
                <button class="tablinks" onclick="opencode(event, 'python')">Python</button>
                <button class="tablinks" onclick="opencode(event, 'posix')">POSIX</button>
                <button class="tablinks" onclick="opencode(event, 'java')">Java</button>
                <button class="tablinks" onclick="opencode(event, 'windows')">Windows</button>
                -->
            </div>
    
            <!-- Tab content -->
            <div id="rustchannel" class="tabcontent">
                <h3>Rust (Channels)</h3>
                <dl>
                    <b>Content</b>
                    <ul>
                        <li><a href="#what">Channel?</a></li>
                        <li><a href="#types">Types of Channels</a></li>
                        <ul>
                            <dt>
                            <li><a href="#t1">Unbounded, sync, (Multi-Producer Single-Consumer)</a></li>
                            <li><a href="#t2">Bounded, sync, (Multi-Producer Single-Consumer)</a></li>
                            <li><a href="#t3">Unbounded, async, (Multi-Producer Multi-Consumer)</a></li>
                            </dt>
                        </ul>
                    </ul>
                </dl>

                <h4 id="what">What is Channel?</h4>
                <dt>
                    Sender<T> and Receiver<T> are connected via Channel. They can send/recv data via channel.
                </dt>

                <h4>Types Channels?</h4>
                <table>
                    <tr>
                        <th></th>
                        <th><a href="#mpsc">mpsc / Multi-Producer, Single-Consumer</a></th>
                        <th><a href="#t3">tokio async_channel / Multi-Producer, Multiple-Consumer</a></th>
                    </tr>
                    <tr>
                        <td>Producer, Consumer</td>
                        <td>Multi Producer, 1 Consumer</td>
                        <td>Multi Producer, Multi Consumer</td>
                    </tr>
                    <tr>
                        <td>Provided by</td>
                        <td>Standard library</td>
                        <td>Tokio runtime</td>
                    </tr>
                    <tr id="unbounded">
                        <td>Unbounded</td>
                        <td>
                            Unbounded means that the channel has no limit on the number of messages it can hold at a time.<br>
                            Sender can continue sending messages indefinitely, they will accumulate in memory until the receiver consumes them.<br><br>
                            <b>Yes</b>
                        </td>
                        <td>Yes</td>
                    </tr>
                    <tr id="asynchronousmeaning">
                        <td>Asynchronous</td>
                        <td>
                            Means that the sending and receiving operations are non-blocking<br>
                            Sender and receiver can proceed independently<br><br>
                            <b>NO. This is synchronous</b>
                        </td>
                        <td>
                            Operations are non-blocking and can be awaited. <br><br>
                            <b>Yes. This is Asynchronous</b>
                        </td>
                    </tr>
                    <tr>
                        <td>Blocking</td>
                        <td>
                            <b>Yes its Blocking,</b> since its not synchronous
                        </td>
                        <td>
                            No blocking<br>
                            No one waits on channel(neither sender, nor rcvr)<br>
                            When all Senders or all Receivers are dropped, the channel becomes closed
                        </td>
                    </tr>
                </table>

                <h5 id="mpsc">Multi-Producer, Single-Consumer (mpsc)</h5>
                <table>
                    <tr>
                        <th id="t1">Unbounded, synchronous Channel</th>
                        <th id="t2">Bounded, synchronous Channel</th>
                    </tr>
                    <tr>
                        <td>
                            <a href="#unbounded">Unbounded?</a><br>
                            <a href="#asynchronousmeaning">Synchronous?</a>
                            <pre><code class="language-css">
fn main() {
    let (tx, rx) = std::sync::mpsc::channel();
    match tx.send(1) {      //send() returns Result
        Ok(_o) => {
            println!("Sent");
        },
        Err(e) => println!("Sending error {}", e)
    };
    match rx.recv() {       //recv() returns Result
        Ok(o) => {
            println!("Recieved {}", o);
        },
        Err(e) => println!("Sending error {}", e)
    };
}
$ cargo run
Sent
Recieved 1
                        </code></pre></td>
                        <td><pre><code class="language-css">
use std::thread;
use std::time::Duration;
use std::sync::mpsc;

fn main() {
    let mut handles = vec![];

    // Create a synchronous channel with a buffer size of 1
    let (t,r) = mpsc::sync_channel::<i32>(1);
    
    // Create 3 threads using a for loop
    for i in 0..3 {
        let tx = t.clone();     // Clone the sender for each thread
        // Spawn a new thread
        let handle = thread::spawn(move || {
            println!("Thread {} has finished", i);
            tx.send(i as i32).unwrap();
        });

        // Store the thread handle to join later
        handles.push(handle);
    }

    // Receive messages from threads
    for _ in 0..3 {
        let received = r.recv().unwrap(); // Receive from the channel
        println!("Received from thread: {}", received);
    }
    
    // Wait for all threads to finish
    for handle in handles {
        handle.join().unwrap();
    }

    println!("All threads have completed.");
}
$ cargo run
Thread 0 has finished
Thread 1 has finished
Thread 2 has finished
Received from thread: 0
Received from thread: 1
Received from thread: 2
All threads have completed.
                        </code></pre></td>
                    </tr>
                </table>
                


                <h5 id="t3">Asynchronous channel (multi-producer, multi-consumer)</h5>
                <pre><code class="language-css">
# Cargo.toml
[package]
name = "async_channel"
version = "0.1.0"
edition = "2018"

[dependencies]
async-channel = {version = "1.5"}
tokio = {version = "0.2.*", features = ["full"] }

# main.rs
use async_channel;
async fn fun() {
    let (s, r) = async_channel::unbounded();

    // Send on channel
    assert_eq!(s.send("Hello").await, Ok(()));

    // Receive on channel
    assert_eq!(r.recv().await, Ok("Hello"));
}

fn main() {
    let mut rt = tokio::runtime::Runtime::new().unwrap(); //1. Start tokio runtime
    let local = tokio::task::LocalSet::new();
    local.block_on(&mut rt, async move { fun().await });
}
                </code></pre>
            </div>

    </main>
    <script src="/scripts/prism.js"></script>
    <script src="/scripts/common.js"></script>
</body>
</html>

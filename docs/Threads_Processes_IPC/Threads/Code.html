<!DOCTYPE html>
<html>
<head>
    <title>Thread Code</title>
    <link rel="stylesheet" href="/css/styles.css"/>
    <link rel="stylesheet" href="/css/prism.css" />
</head>

<body>
    <nav class="navbar">    <!--See .navbar in styles.css-->
        <ul>
          <li><a href="/">Home</a></li>
          <li><a href="#">Our team</a></li>
          <li><a href="#">Projects</a></li>
          <li><a href="/contact.html">Contact</a></li>
          <li>
            <form id="searchForm">
                <input type="search" id="searchInput" name="q" placeholder="Search site" />
                <input type="submit" value="Go!" />
            </form>
           </li>
        </ul>
    </nav>

    <div style="margin-left:200px;">
        <h3 id="code">Thread Creation Code</h3>
        <div class="tab">
            <button class="tablinks" onclick="opencode(event, 'cppthreadclass')">CPP(Thread class)</button>
            <button class="tablinks" onclick="opencode(event, 'cppfunctor')">CPP(Functor)</button>
            <button class="tablinks" onclick="opencode(event, 'rust')">Rust</button>
            <button class="tablinks" onclick="opencode(event, 'python')">Python</button>
            <button class="tablinks" onclick="opencode(event, 'posix')">POSIX</button>
            <button class="tablinks" onclick="opencode(event, 'java')">Java</button>
            <button class="tablinks" onclick="opencode(event, 'windows')">Windows</button>
        </div>

        <!-- Tab content -->
        <div id="cppthreadclass" class="tabcontent">
            <h4>CPP(Thread class)</h4>
            <pre><code class="language-css">
#include &lt;thread>
#include &lt;iostream>
void fun(int a){
    std::cout &lt;&lt; "Hello";
}
int main() { 
    int a = 10;
    //Creates Thread Object, 
    //which is entity that can start 
    //execution immediately after creation
    std::thread t1(fun, a);
    t1.join();
    
    /* Not copy construtible */
    //error: use of deleted function 
    ‘std::thread::thread(std::thread&)’
    //std::thread t2 = t1
    
    /* Not copy assignable */
    //error: use of deleted function 
    //‘std::thread& std::thread::operator
    //=(const std::thread&)’
    //std::thread t2(fun,3);
    //t1 = t2;
}
                </code></pre>
<br>
- Thread calling method of class
                <pre><code class="language-css">
#include&lt;thread>
class A {
    void test(int a) {
        cout &lt;&lt; a;
    }
public:
    void fun(int a) {
        //if we start thread on static function, 
        //then this will not be passed
        thread t1(&A::test, this, a);
        t1.join();
    }
};
int main() {
    A obj;
    obj.fun(1);
}
            </code></pre>
        </div>

        <div id="cppfunctor" class="tabcontent">
            <h4>CPP(Functor)</h4>
<pre><code class="language-css">
#include &lt;thread>
#include &lt;iostream>
#include &lt;mutex>
#include &lt;vector>
std::mutex m;

void fun(int tid) {
    int a;
    m.lock();
    a += 5;
    std::cout &lt;&lt; 
    "Thread: " &lt;&lt; 
    tid &lt;&lt; ", a:
    " &lt;&lt; a &lt;&lt; std::endl;
    m.unlock();
}

int main() {
    std::vector<std::thread> vecThreads;
    for (int i = 0; i&lt; 5; ++i) {
        //Functor to create Threads
        vecThreads.emplace_back(
            [&]() {
                fun(i);
            }
        );
    }
    for (auto& t : vecThreads)
        t.join();
    return 0;
}
</code></pre>
    </div>

    <div id="rust" class="tabcontent">
        <h3>Rust</h3>
        <dl>
            <b>Creating Threads</b>
            <ul>
                <li><a href="#spawn">1. std::thread::spawn</a></li>
                <li><a href="#builder">2. std::thread::Builder()</a></li>
                <li><a href="#async">3. Asynchronous Frameworks (e.g., Tokio)</a></li>
            </ul>
        </dl>


        <h4>Creating Threads</h4>
        <h5 id="spawn">1. std::thread::spawn</h5>
        <dl>
            thread::spawn() takes a <a href="https://github.com/code-with-amitk/Code-examples/tree/master/Languages/Programming_Languages/Rust/Functions#closure">closure</a> 
            as an argument, which contains the code to be executed in the new thread
        </dl>
        <table>
            <tr>
                <th>Normal Closure</th>
                <th>Scoped Threads(Borrow from env)</th>
                <th>Move Closure</th>
            </tr>
            <tr>
                <td>
                    <pre><code class="language-css">
$ cat main.rs
use std::thread;
fn fun1() {
    println!("Thread-1");
}

fn main() {
    let handle1 = thread::spawn(fun1);      //Thread-1

    let handle2 = thread::spawn(||{         //Thread-2
            println! ("Thread-2");
        });

    // Thread1, Thread2 are joinable.
    // main will not exit without t1,t2
    // spawn() returns Struct std::thread::JoinHandle 
    // which has method join() 
    handle1.join().unwrap();
    handle2.join().unwrap();
}
$ cargo run
                    </code></pre>
                </td>
                <td>
                    Normal Threads cannot borrow from their environment,<br>
                    but scoped threads can<br><br>
                    <b>Scoped threads are not required to joined:</b><br>
                    - Reason being, when scoped thread completes, its required<br>
                    to return the borrowed data
                    <pre><code class="language-css">
fn main() {
    let a = 1;

    thread::scope(|scope| {
        scope.spawn(|| {
            println!("{}", a);
        });
    });
}
                    </code></pre>
                </td>
                <td>
                    <dl>
                        The move keyword indicates that the closure <br>
                        will take ownership of any variables it <br>
                        captures from its environment.
                    </dl>
<pre><code class="language-css">
use std::thread;

fn main() {
    let a = 10;
    let handle = thread::spawn(move || {
        println!("Thread {}", a);
    });

    handle.join().unwrap(); // Wait for the thread to finish
}
</code></pre>
                </td>
            </tr>
        </table>

        <h5 id="builder">2. std::thread::Builder</h5>
        <dl>
            Allows for more control over thread creation, such as setting stack size or naming the thread
        </dl>
        <pre><code class="language-css">
use std::thread;

let builder = thread::Builder::new().name("my_thread".into()).stack_size(32 * 1024);
let handle = builder.spawn(|| {
    println!("Hello from a custom thread!");
}).unwrap();
handle.join().unwrap();
        </code></pre>

        <h5 id="async">3. Asynchronous Frameworks (e.g., Tokio)</h5>
        <dl>
            For asynchronous programming, you can use libraries like Tokio, which allows you to spawn tasks on a runtime.
        </dl>
        <pre><code class="language-css">
#[tokio::main]
async fn main() {
    tokio::spawn(async {
        println!("Hello from an async task!");
    });
    // Other async code...
}
        </code></pre>

    </div>

    <div id="python" class="tabcontent">
        <h4>Python</h4>
        <pre><code class="language-css">
import threading, zipfile

class AsyncZip(threading.Thread):
    def __init__(self, infile, outfile):              # Constructor
        threading.Thread.__init__(self)
        self.infile = infile
        self.outfile = outfile

    def run(self):
        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
        f.write(self.infile)
        f.close()
        print('Finished background zip of:', self.infile)

background = AsyncZip('mydata.txt', 'myarchive.zip')
background.start()
print('The main program continues to run in foreground.')

background.join()    # Wait for the background task to finish
print('Main program waited until background was done.')
        </code></pre>
    </div>

    <div id="posix" class="tabcontent">
        <h4>POSIX</h4>
        <pre><code class="language-css">
#include &lt;pthread.h>
#include &lt;iostream>
using namespace std;
#define NUM_OF_THREADS 5

void* worker (void* arg) {
    <!--cout "<<" "Thread: " "<<" *((int*)arg) << " Created" << endl;-->
    cout &lt;&lt; "Thread: " &lt;&lt; *((int*)arg) &lt;&lt; " Created" &lt;&lt; endl;
}

int main() {
    pthread_t thread_id[NUM_OF_THREADS];
    int thread_args[NUM_OF_THREADS], ret;

    <!-- for (int i=0;i<NUM_OF_THREADS;++i) { -->
    for (int i=0;i&lt;NUM_OF_THREADS;++i) {
        thread_args[i] = i;
        ret = pthread_create(&thread_id[i], 0, worker, (void*)&thread_args[i]);
    }

    for (int i=0; i &lt NUM_OF_THREADS;++i)
        pthread_join (thread_id[i], 0);
    return 0;
}
        </code></pre>
    </div>

    <div id="java" class="tabcontent">
        <h4>Java</h4>
        <pre><code class="language-css">
//Class should implement Runnable Interface to create Thread
class test implements Runnable {		
    test() {
        Thread cur = Thread.currentThread();

        //1. Created child thread
        Thread t = new Thread (this, "New thread");

        //2. Started child thread. 
        //if start() is not called, Child Thread will not start
        t.start();                                  
        try {
            for (int i = 0; i &lt; 6; ++i) {
                //Parent process waits 1sec
                System.out.println ("Parent Thread");
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            System.out.println ("Interrupted");
        }
        System.out.println ("exiting main thread");
    }
    public void run () {
        try {
            for (int i = 0; i &lt; 3; ++i) {
                //Child Thread waits 2sec
                System.out.println ("Child Thread");
                Thread.sleep(2000);
            }
        }
        catch (InterruptedException e) {
            System.out.println ("child interrupted");
        }
        System.out.println ("exiting child thread");
    }
    public static void main (String args[]) {
        new test();					//1. Calls constructor
    }
}
$ javac test.java
$ java test
$ java test
Parent Thread
Child Thread
Parent Thread
Child Thread
Parent Thread
Parent Thread
Child Thread
Parent Thread
Parent Thread
exiting child thread
exiting main thread
        </code></pre>
    </div>

    <div id="windows" class="tabcontent">
        <h4>Windows</h4>
        <pre><code class="language-css">
#include &lt;windows.h>
#include &lt;tchar.h>
#include &lt;strsafe.h>
using namespace std;
DWORD WINAPI worker(LPVOID param) {
    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    int* data = (int*)param;
    TCHAR buf[60];
    DWORD dwChar;
    StringCchPrintf(buf, 60, TEXT("val=%d"), *data);
    WriteConsole(hStdout, buf, 10, &dwChar, nullptr);
    return 0;
}

int _tmain() {
    DWORD thread_id[5];
    for (int i = 0; i &lt; 5; ++i) {
        CreateThread(
            NULL,               //Default security attributes
            0,                  //Use default stack size
            worker,             //thread function
            (void*)i,           //argument to thread function
            0,                  //Default creation flag
            &thread_id[i]);     //Thread identifier returned
    }
}
        </code></pre>
    </div>

    </div>
    <script src="/scripts/prism.js"></script>
    <script src="/scripts/common.js"></script>
</body>

</html>
